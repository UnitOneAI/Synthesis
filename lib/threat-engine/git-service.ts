import simpleGit from "simple-git";
import { Octokit } from "@octokit/rest";
import fs from "fs";
import path from "path";
import os from "os";

// ── Types ──

export interface ApplyFixResult {
  success: boolean;
  prUrl?: string;
  branch?: string;
  commitSha?: string;
  error?: string;
}

export interface RepoInfo {
  owner: string;
  repo: string;
  defaultBranch: string;
}

// ── Clone Service ──

export async function cloneRepo(
  repoUrl: string,
  targetDir: string
): Promise<void> {
  let gitUrl = repoUrl;
  if (!gitUrl.startsWith("http") && !gitUrl.startsWith("git@")) {
    gitUrl = `https://${gitUrl}`;
  }
  if (!gitUrl.endsWith(".git")) {
    gitUrl = `${gitUrl}.git`;
  }

  const git = simpleGit();
  await git.clone(gitUrl, targetDir, ["--depth", "1"]);
}

// ── Parse GitHub URL ──

export function parseGitHubUrl(url: string): RepoInfo | null {
  // Handle formats:
  // https://github.com/owner/repo
  // github.com/owner/repo
  // git@github.com:owner/repo.git
  const patterns = [
    /github\.com[/:]([^/]+)\/([^/.]+?)(?:\.git)?$/,
    /github\.com[/:]([^/]+)\/([^/.]+?)(?:\.git)?(?:\?.*)?$/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) {
      return {
        owner: match[1],
        repo: match[2],
        defaultBranch: "main",
      };
    }
  }

  return null;
}

// ── Apply Fix (create branch, commit, PR) ──

export async function applyFix(
  repoUrl: string,
  threatId: string,
  threatTitle: string,
  filePath: string,
  originalCode: string,
  fixedCode: string
): Promise<ApplyFixResult> {
  let githubToken = process.env.GITHUB_TOKEN;
  if (!githubToken) {
    // Fallback to DB settings
    try {
      const { getSettingValue } = await import("@/lib/db");
      githubToken = getSettingValue("github_token") || undefined;
    } catch {
      // DB not available
    }
  }
  if (!githubToken) {
    return {
      success: false,
      error: "GITHUB_TOKEN environment variable is required to create PRs",
    };
  }

  const repoInfo = parseGitHubUrl(repoUrl);
  if (!repoInfo) {
    return {
      success: false,
      error: `Could not parse GitHub URL: ${repoUrl}`,
    };
  }

  const octokit = new Octokit({ auth: githubToken });
  const branchName = `fix/threat-${threatId.toLowerCase().replace(/[^a-z0-9]/g, "-")}`;

  try {
    // 1. Get the default branch SHA
    const { data: repo } = await octokit.repos.get({
      owner: repoInfo.owner,
      repo: repoInfo.repo,
    });
    const defaultBranch = repo.default_branch;

    const { data: ref } = await octokit.git.getRef({
      owner: repoInfo.owner,
      repo: repoInfo.repo,
      ref: `heads/${defaultBranch}`,
    });
    const baseSha = ref.object.sha;

    // 2. Create the branch
    try {
      await octokit.git.createRef({
        owner: repoInfo.owner,
        repo: repoInfo.repo,
        ref: `refs/heads/${branchName}`,
        sha: baseSha,
      });
    } catch (e: unknown) {
      const error = e as { status?: number };
      // Branch might already exist — that's OK, we'll update it
      if (error.status !== 422) throw e;
    }

    // 3. Get current file content
    const { data: fileData } = await octokit.repos.getContent({
      owner: repoInfo.owner,
      repo: repoInfo.repo,
      path: filePath,
      ref: branchName,
    });

    if (Array.isArray(fileData) || fileData.type !== "file") {
      return {
        success: false,
        error: `${filePath} is not a file`,
      };
    }

    // 4. Apply the fix (replace original code with fixed code in the file)
    const currentContent = Buffer.from(fileData.content, "base64").toString(
      "utf-8"
    );
    const updatedContent = currentContent.replace(originalCode, fixedCode);

    if (updatedContent === currentContent) {
      return {
        success: false,
        error:
          "Could not find the original code snippet in the file. The code may have already been modified.",
      };
    }

    // 5. Commit the change
    const { data: commitData } = await octokit.repos.createOrUpdateFileContents(
      {
        owner: repoInfo.owner,
        repo: repoInfo.repo,
        path: filePath,
        message: `fix(security): ${threatId} - ${threatTitle}\n\nApplied automated security fix from Unitone Sentinel threat model.\nSTRIDE Category: Mitigation applied.\n\nGenerated by Unitone Sentinel Threat Modeling`,
        content: Buffer.from(updatedContent).toString("base64"),
        sha: fileData.sha,
        branch: branchName,
      }
    );

    // 6. Create the PR
    const { data: pr } = await octokit.pulls.create({
      owner: repoInfo.owner,
      repo: repoInfo.repo,
      title: `fix(security): ${threatId} - ${threatTitle}`,
      body: `## Security Fix — Unitone Sentinel

**Threat ID:** ${threatId}
**Threat:** ${threatTitle}

### Changes
- Applied automated security fix to \`${filePath}\`
- Fix generated by Unitone Sentinel threat modeling engine

### Original Code
\`\`\`
${originalCode}
\`\`\`

### Fixed Code
\`\`\`
${fixedCode}
\`\`\`

---
*Generated by [Unitone Sentinel](https://unitone.ai) Threat Modeling*`,
      head: branchName,
      base: defaultBranch,
    });

    return {
      success: true,
      prUrl: pr.html_url,
      branch: branchName,
      commitSha: commitData.commit.sha ?? undefined,
    };
  } catch (e: unknown) {
    const error = e as { message?: string; status?: number };
    return {
      success: false,
      error: `GitHub API error: ${error.message || "Unknown error"} (status: ${error.status || "unknown"})`,
    };
  }
}

// ── Local file fix (no GitHub — for testing) ──

export async function applyFixLocally(
  repoDir: string,
  filePath: string,
  originalCode: string,
  fixedCode: string,
  threatId: string,
  threatTitle: string
): Promise<ApplyFixResult> {
  try {
    const fullPath = path.join(repoDir, filePath);

    if (!fs.existsSync(fullPath)) {
      return { success: false, error: `File not found: ${filePath}` };
    }

    const content = fs.readFileSync(fullPath, "utf-8");
    const updatedContent = content.replace(originalCode, fixedCode);

    if (updatedContent === content) {
      return {
        success: false,
        error: "Could not find original code to replace",
      };
    }

    fs.writeFileSync(fullPath, updatedContent, "utf-8");

    // Git commit locally
    const git = simpleGit(repoDir);
    const branchName = `fix/threat-${threatId.toLowerCase().replace(/[^a-z0-9]/g, "-")}`;

    try {
      await git.checkoutLocalBranch(branchName);
    } catch {
      // Branch may already exist
      await git.checkout(branchName);
    }

    await git.add(filePath);
    await git.commit(
      `fix(security): ${threatId} - ${threatTitle}\n\nGenerated by Unitone Sentinel`
    );

    const log = await git.log({ maxCount: 1 });

    return {
      success: true,
      branch: branchName,
      commitSha: log.latest?.hash,
    };
  } catch (e: unknown) {
    const error = e as { message?: string };
    return {
      success: false,
      error: `Local fix error: ${error.message || "Unknown error"}`,
    };
  }
}
